The SumParser
=============

The sumparser parses sum-lines and stortes the bandwidth sum. Unlike the `IperfParser` it uses the summed lines that iperf calculates. This means that if intervals and parallel threads were used and within one (or more) of those intervals one or more of the threads didn't report its value then the interval-sums will have fewer values than there were intervals (iperf will just skip summing an interval that didn't have all the threads reporting back). The ``IperfParser``, in contrast, will under-report the interval (unless the thread was actually dead) but it will at least give you a value. On the other hand, if all the sum-lines were there, then this would presumably be the more accurate method since we're taking what iperf itself reports.

.. '

<<name='imports', echo=False>>=
#python standard library
import os

#this package
from iperfparser import IperfParser 
from iperfexpressions import HumanExpression, ParserKeys, CsvExpression
import oatbran as bran
from coroutine import coroutine
@

The HumanExpressionSum Class
----------------------------

.. uml::

   HumanExpression <|-- HumanExpressionSum

.. module:: iperflexer.sumparser
.. autosummary::
   :toctree: api

   HumanExpression
   HumanExpression.thread_column   

<<name='HumanExpressionSum', echo=False>>=
class HumanExpressionSum(HumanExpression):
    """
    Changes the thread-column regular expression to match SUMS if needed
    """
    def __init__(self, threads=4):
        """
        :param:

         - `threads`: number of parallel threads
        """
        super(HumanExpressionSum, self).__init__()
        self.threads = threads
        return

    @property
    def thread_column(self):
        """
        :return: expression to match the thread (sum) column
        """
        if self._thread_column is None:
            if self.threads > 1:
                thread = "SUM"
            else:
                thread = bran.OPTIONAL_SPACES + bran.INTEGER
            self._thread_column = bran.L_BRACKET + thread + bran.R_BRACKET
        return self._thread_column
# end class HumanExpressionSum
@

CsvExpressionSum Class
----------------------

.. uml::

   CsvExpression <|-- CsvExpressionSum

.. autosummary::
   :toctree: api

   CsvExpressionSum
   CsvExpressionSum.thread_column   

<<name='CsvExpressionSum', echo=False>>=
class CsvExpressionSum(CsvExpression):
    """
    Changes the thread column to look for -1 if needed
    """
    def __init__(self, threads=4):
        """
        :param:

         - `threads`: the number of parallel threads
        """
        super(CsvExpressionSum, self).__init__()
        self.threads = threads
        return

    @property
    def thread_column(self):
        """
        :return: the expression to match the thread (sum) column
        """
        if self._thread_column is None:
            if self.threads > 1:
                thread = "-1"
            else:
                thread = bran.INTEGER
            self._thread_column = bran.NAMED(ParserKeys.thread, thread)
        return self._thread_column
# end class CsvExpressionSum    
@    

The SumParser
-------------

.. uml::

   IperfParser <|-- SumParser
   SumParser: __call__(line)
   SumParser: last_line_bandwidth

.. autosummary::
   :toctree: api

   SumParser
   SumParser.__call__
   SumParser.pipe

<<name='SumParser', echo=False>>=
class SumParser(IperfParser):
    """
    The SumParser emits bandwidth sum lines
    """
    def __init__(self, *args, **kwargs):
        super(SumParser, self).__init__(*args, **kwargs)
        self.log_format = "({0}) {1} {2}/sec"
        self.last_line_bandwidth = None
        return

    @property
    def regex(self):
        """
        :return: a dictionary of compiled regular expressions
        """
        if self._regex is None:
            self._regex = {ParserKeys.human:HumanExpressionSum(threads=self.threads).regex,
                           ParserKeys.csv:CsvExpressionSum(threads=self.threads).regex}
        return self._regex

    def __call__(self, line):
        """
        The Main interface to add raw iperf lines to the parser
        
        :param:

         - `line`: a line of iperf output

        :return: bandwidth or None
        """
        match = self.search(line)
        assert type(match) == dict or match is None, "match: {0}".format(type(match)) 
        bandwidth = None
        if match is not None:
            bandwidth = self.bandwidth(match)
            if self.valid(match):                        
                self.intervals[float(match[ParserKeys.start])] = bandwidth
                self.logger.info(self.log_format.format(match[ParserKeys.start],
                                                        bandwidth,
                                                        self.units))
            else:
                # Assume it's the last line summary
                self.last_line_bandwidth = bandwidth
                return
        return bandwidth

    @coroutine
    def pipe(self, target):
        """
        A coroutine pipeline segment
                
        :warnings:

         - For bad connections with threads this might break (as the threads die)
         - Use for good connections or live data only (use `bandwidths` and completed data for greater fidelity)
         
        :parameters:

         - `target`: a target to send matched output to

        :send:

         - bandwidth converted to self.units as a float
        """
        while True:
            line = (yield)
            match = self.search(line)
            if match is not None and self.valid(match):
                # threads is a dict of interval:(thread_count, bandwidths)
                target.send(self.bandwidth(match))
        return
# end class SumParser
@

Using the SumParser
-------------------

Checking The Call Output
------------------------

The ``__call__`` is the main way to use it. There are two ways to get the interval sums from the SumParser (and the IperfParser). One is to poll the returned value from the ``__call__`` to see if a value was returned.

<<name='check_pweave', echo=False>>=
in_pweave = __name__ == '__builtin__'
@

<<name='check_call', wrap=False>>=
if in_pweave:
    data_folder = 'features/steps/samples/'
    data_path = os.path.join(data_folder, 'client_data.iperf')
    parser = SumParser()
    for line in open(data_path):
        bandwidth = parser(line)
        if bandwidth is not None:
            print(bandwidth)
@

.. warning:: the returned value is a float, not a string so it has to be cast to a string to be saved (don't do ``bandwidth + '\n'``).

.. '

Traversing the Values
---------------------

The original way to use it is to add all the lines and traverse the bandwidths afterwards. For the ``IperfParser`` this might be the safer way to use it if the data is being fed to it live while iperf is running, since it's adding up the threads, but for the ``SumParser`` I can't think of a down-side to either way (other than the warning about missing data for late threads noted at the top).

<<name='traverse_bandwidths', wrap=False>>=
if in_pweave:
    parser.reset()

    for line in open(data_path):
        parser(line)
    
    for bandwidth in parser.bandwidths:
        print(bandwidth)

@    
           
The Last Line Bandwidth
-----------------------

When the `SumParser` matches a line that has an interval larger than what it is set to accept then it will set its ``last_line_bandwidth`` attribute to it, so once the whole iperf output has been consumed that attribute will have the final bandwidth value that iperf calculated for the entire session, assuming that the output is complete and this was the last line. If the line is missing it should be None.

Based on some empirical checking and some threads on the iperf discussion boards it looks like this is the most accurate value if there is a discrepancy between it and the added interval sums.

<<name='last_line_bandwidth', wrap=False>>=
if in_pweave:
    parser.reset()

    for line in open(data_path):
        parser(line)
    
    bandwidths = [bandwidth for bandwidth in parser.bandwidths]
    calculated_average = sum(bandwidths)/len(bandwidths)
    print('Calculated Mean: {0} Mbits/Second'.format(calculated_average))
    print("Iperf's Mean: {0} Mbits/Second".format(parser.last_line_bandwidth))
@

So... the calculated mean is higher... I don't really know what this means. My guess would be that this is a problem of loss of precision in converting everything into Mbits/second. Let's try an iperf file that used bits as the units.

<<name='bits_sums', wrap=False>>=
if in_pweave:
    #set up the unitconverter
    from unitconverter import UnitConverter
    converter = UnitConverter()
    data_path = os.path.join(data_folder, 'client_p4_bits.iperf')

    #setup the parsers to use bits
    sum_parser = parser
    voodoo = IperfParser(units='bits')
    sum_parser.reset()
    sum_parser.units = 'bits'

    # load them up with the raw lines
    for line in open(data_path):
        sum_parser(line)
        voodoo(line)

    # convert the sums to Mbits and take the average
    bandwidths = [bandwidth for bandwidth in parser.bandwidths]
    total_bandwidth = sum(bandwidths) * converter['bits']['Mbits']
    calculated_average = total_bandwidth/len(bandwidths)

    # same for the re-added threads
    v_bandwidths = [bandwidth for bandwidth in voodoo.bandwidths]
    v_total = sum(v_bandwidths) * converter['bits']['Mbits']
    v_average = v_total/len(v_bandwidths)

    # now iperf's
    iperf_mean = sum_parser.last_line_bandwidth * converter['bits']['Mbits']
    
    print('Calculated Mean: {0} Mbits/Second'.format(calculated_average))
    print("Iperf's Mean: {0} Mbits/Second".format(iperf_mean))
    print("Thread Re-calculated Mean: {0} Mbits/Second".format(v_average))          
@

So in this case, since there were no threads with missing intervals the SumParser and the IperfParser came up with the same values but both were higher than iperf's calculated final value.

